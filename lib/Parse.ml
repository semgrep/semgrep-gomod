(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_gomod"

let parse_source_string ?src_file contents =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "comment";
]

let children_regexps : (string * Run.exp option) list = [
  "raw_string_literal", None;
  "identifier", None;
  "imm_tok_prec_p1_pat_101b4f2", None;
  "pat_4fd4a56", None;
  "escape_sequence", None;
  "file_path", Some (Token (Name "identifier"););
  "comment",
  Some (
    Seq [
      Token (Literal "//");
      Token (Name "pat_4fd4a56");
    ];
  );
  "interpreted_string_literal",
  Some (
    Seq [
      Token (Literal "\"");
      Repeat (
        Alt [|
          Token (Name "imm_tok_prec_p1_pat_101b4f2");
          Token (Name "escape_sequence");
        |];
      );
      Token (Literal "\"");
    ];
  );
  "string_literal",
  Some (
    Alt [|
      Token (Name "raw_string_literal");
      Token (Name "interpreted_string_literal");
    |];
  );
  "string_or_ident",
  Some (
    Alt [|
      Token (Name "string_literal");
      Token (Name "identifier");
    |];
  );
  "module_path", Some (Token (Name "string_or_ident"););
  "tool", Some (Token (Name "string_or_ident"););
  "toolchain_name", Some (Token (Name "string_or_ident"););
  "version", Some (Token (Name "string_or_ident"););
  "go_version", Some (Token (Name "string_or_ident"););
  "module_directive",
  Some (
    Seq [
      Token (Literal "module");
      Alt [|
        Token (Name "module_path");
        Seq [
          Token (Literal "(");
          Token (Literal "\n");
          Token (Name "module_path");
          Token (Literal "\n");
          Token (Literal ")");
        ];
      |];
    ];
  );
  "tool_directive",
  Some (
    Seq [
      Token (Literal "tool");
      Alt [|
        Token (Name "tool");
        Seq [
          Token (Literal "(");
          Token (Literal "\n");
          Repeat (
            Token (Name "tool");
          );
          Token (Literal ")");
          Token (Literal "\n");
        ];
      |];
    ];
  );
  "toolchain_directive",
  Some (
    Seq [
      Token (Literal "toolchain");
      Token (Name "toolchain_name");
    ];
  );
  "require_spec",
  Some (
    Seq [
      Token (Name "module_path");
      Token (Name "version");
      Token (Literal "\n");
    ];
  );
  "exclude_spec",
  Some (
    Seq [
      Token (Name "module_path");
      Token (Name "version");
      Token (Literal "\n");
    ];
  );
  "replace_spec",
  Some (
    Alt [|
      Seq [
        Token (Name "module_path");
        Opt (
          Token (Name "version");
        );
        Token (Literal "=>");
        Token (Name "file_path");
        Token (Literal "\n");
      ];
      Seq [
        Token (Name "module_path");
        Opt (
          Token (Name "version");
        );
        Token (Literal "=>");
        Token (Name "module_path");
        Token (Name "version");
        Token (Literal "\n");
      ];
    |];
  );
  "retract_spec",
  Some (
    Seq [
      Alt [|
        Seq [
          Token (Literal "[");
          Token (Name "version");
          Token (Literal ",");
          Token (Name "version");
          Token (Literal "]");
        ];
        Token (Name "version");
      |];
      Token (Literal "\n");
    ];
  );
  "go_directive",
  Some (
    Seq [
      Token (Literal "go");
      Token (Name "go_version");
      Token (Literal "\n");
    ];
  );
  "require_directive",
  Some (
    Seq [
      Token (Literal "require");
      Alt [|
        Token (Name "require_spec");
        Seq [
          Token (Literal "(");
          Token (Literal "\n");
          Repeat (
            Token (Name "require_spec");
          );
          Token (Literal ")");
          Token (Literal "\n");
        ];
      |];
    ];
  );
  "exclude_directive",
  Some (
    Seq [
      Token (Literal "exclude");
      Alt [|
        Token (Name "exclude_spec");
        Seq [
          Token (Literal "(");
          Token (Literal "\n");
          Repeat (
            Token (Name "exclude_spec");
          );
          Token (Literal ")");
          Token (Literal "\n");
        ];
      |];
    ];
  );
  "replace_directive",
  Some (
    Seq [
      Token (Literal "replace");
      Alt [|
        Token (Name "replace_spec");
        Seq [
          Token (Literal "(");
          Token (Literal "\n");
          Repeat (
            Token (Name "replace_spec");
          );
          Token (Literal ")");
          Token (Literal "\n");
        ];
      |];
    ];
  );
  "retract_directive",
  Some (
    Seq [
      Token (Literal "retract");
      Alt [|
        Seq [
          Token (Literal "(");
          Token (Literal "\n");
          Repeat (
            Token (Name "retract_spec");
          );
          Token (Literal ")");
          Token (Literal "\n");
        ];
        Token (Name "retract_spec");
      |];
    ];
  );
  "directive",
  Some (
    Alt [|
      Token (Name "module_directive");
      Token (Name "go_directive");
      Token (Name "tool_directive");
      Token (Name "toolchain_directive");
      Token (Name "require_directive");
      Token (Name "exclude_directive");
      Token (Name "replace_directive");
      Token (Name "retract_directive");
    |];
  );
  "source_file",
  Some (
    Repeat (
      Token (Name "directive");
    );
  );
]

let trans_raw_string_literal ((kind, body) : mt) : CST.raw_string_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_imm_tok_prec_p1_pat_101b4f2 ((kind, body) : mt) : CST.imm_tok_prec_p1_pat_101b4f2 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_4fd4a56 ((kind, body) : mt) : CST.pat_4fd4a56 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_escape_sequence ((kind, body) : mt) : CST.escape_sequence =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_file_path ((kind, body) : mt) : CST.file_path =
  match body with
  | Children v ->
      trans_identifier (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_comment ((kind, body) : mt) : CST.comment =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_pat_4fd4a56 (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_interpreted_string_literal ((kind, body) : mt) : CST.interpreted_string_literal =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                (match v with
                | Alt (0, v) ->
                    `Imm_tok_prec_p1_pat_101b4f2 (
                      trans_imm_tok_prec_p1_pat_101b4f2 (Run.matcher_token v)
                    )
                | Alt (1, v) ->
                    `Esc_seq (
                      trans_escape_sequence (Run.matcher_token v)
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_string_literal ((kind, body) : mt) : CST.string_literal =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Raw_str_lit (
            trans_raw_string_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Inte_str_lit (
            trans_interpreted_string_literal (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_string_or_ident ((kind, body) : mt) : CST.string_or_ident =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Str_lit (
            trans_string_literal (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_module_path ((kind, body) : mt) : CST.module_path =
  match body with
  | Children v ->
      trans_string_or_ident (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_tool ((kind, body) : mt) : CST.tool =
  match body with
  | Children v ->
      trans_string_or_ident (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_toolchain_name ((kind, body) : mt) : CST.toolchain_name =
  match body with
  | Children v ->
      trans_string_or_ident (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_version ((kind, body) : mt) : CST.version =
  match body with
  | Children v ->
      trans_string_or_ident (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_go_version ((kind, body) : mt) : CST.go_version =
  match body with
  | Children v ->
      trans_string_or_ident (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_module_directive ((kind, body) : mt) : CST.module_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Module_path (
                  trans_module_path (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_LF_module_path_LF_RPAR (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1),
                        trans_module_path (Run.matcher_token v2),
                        Run.trans_token (Run.matcher_token v3),
                        Run.trans_token (Run.matcher_token v4)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_tool_directive ((kind, body) : mt) : CST.tool_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Tool (
                  trans_tool (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_LF_rep_tool_RPAR_LF (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1),
                        Run.repeat
                          (fun v -> trans_tool (Run.matcher_token v))
                          v2
                        ,
                        Run.trans_token (Run.matcher_token v3),
                        Run.trans_token (Run.matcher_token v4)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_toolchain_directive ((kind, body) : mt) : CST.toolchain_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_toolchain_name (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_require_spec ((kind, body) : mt) : CST.require_spec =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_module_path (Run.matcher_token v0),
            trans_version (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_exclude_spec ((kind, body) : mt) : CST.exclude_spec =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            trans_module_path (Run.matcher_token v0),
            trans_version (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_replace_spec ((kind, body) : mt) : CST.replace_spec =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Module_path_opt_vers_EQGT_file_path_LF (
            (match v with
            | Seq [v0; v1; v2; v3; v4] ->
                (
                  trans_module_path (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_version (Run.matcher_token v))
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2),
                  trans_file_path (Run.matcher_token v3),
                  Run.trans_token (Run.matcher_token v4)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Module_path_opt_vers_EQGT_module_path_vers_LF (
            (match v with
            | Seq [v0; v1; v2; v3; v4; v5] ->
                (
                  trans_module_path (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_version (Run.matcher_token v))
                    v1
                  ,
                  Run.trans_token (Run.matcher_token v2),
                  trans_module_path (Run.matcher_token v3),
                  trans_version (Run.matcher_token v4),
                  Run.trans_token (Run.matcher_token v5)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_retract_spec ((kind, body) : mt) : CST.retract_spec =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            (match v0 with
            | Alt (0, v) ->
                `LBRACK_vers_COMMA_vers_RBRACK (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_version (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2),
                        trans_version (Run.matcher_token v3),
                        Run.trans_token (Run.matcher_token v4)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Vers (
                  trans_version (Run.matcher_token v)
                )
            | _ -> assert false
            )
            ,
            Run.trans_token (Run.matcher_token v1)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_go_directive ((kind, body) : mt) : CST.go_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            trans_go_version (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_require_directive ((kind, body) : mt) : CST.require_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Requ_spec (
                  trans_require_spec (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_LF_rep_requ_spec_RPAR_LF (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1),
                        Run.repeat
                          (fun v -> trans_require_spec (Run.matcher_token v))
                          v2
                        ,
                        Run.trans_token (Run.matcher_token v3),
                        Run.trans_token (Run.matcher_token v4)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_exclude_directive ((kind, body) : mt) : CST.exclude_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Excl_spec (
                  trans_exclude_spec (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_LF_rep_excl_spec_RPAR_LF (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1),
                        Run.repeat
                          (fun v -> trans_exclude_spec (Run.matcher_token v))
                          v2
                        ,
                        Run.trans_token (Run.matcher_token v3),
                        Run.trans_token (Run.matcher_token v4)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_replace_directive ((kind, body) : mt) : CST.replace_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `Repl_spec (
                  trans_replace_spec (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `LPAR_LF_rep_repl_spec_RPAR_LF (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1),
                        Run.repeat
                          (fun v -> trans_replace_spec (Run.matcher_token v))
                          v2
                        ,
                        Run.trans_token (Run.matcher_token v3),
                        Run.trans_token (Run.matcher_token v4)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_retract_directive ((kind, body) : mt) : CST.retract_directive =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1] ->
          (
            Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) ->
                `LPAR_LF_rep_retr_spec_RPAR_LF (
                  (match v with
                  | Seq [v0; v1; v2; v3; v4] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1),
                        Run.repeat
                          (fun v -> trans_retract_spec (Run.matcher_token v))
                          v2
                        ,
                        Run.trans_token (Run.matcher_token v3),
                        Run.trans_token (Run.matcher_token v4)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `Retr_spec (
                  trans_retract_spec (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_directive ((kind, body) : mt) : CST.directive =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Module_dire (
            trans_module_directive (Run.matcher_token v)
          )
      | Alt (1, v) ->
          `Go_dire (
            trans_go_directive (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Tool_dire_c03956b (
            trans_tool_directive (Run.matcher_token v)
          )
      | Alt (3, v) ->
          `Tool_dire_55e7f4a (
            trans_toolchain_directive (Run.matcher_token v)
          )
      | Alt (4, v) ->
          `Requ_dire (
            trans_require_directive (Run.matcher_token v)
          )
      | Alt (5, v) ->
          `Excl_dire (
            trans_exclude_directive (Run.matcher_token v)
          )
      | Alt (6, v) ->
          `Repl_dire (
            trans_replace_directive (Run.matcher_token v)
          )
      | Alt (7, v) ->
          `Retr_dire (
            trans_retract_directive (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_source_file ((kind, body) : mt) : CST.source_file =
  match body with
  | Children v ->
      Run.repeat
        (fun v -> trans_directive (Run.matcher_token v))
        v
  | Leaf _ -> assert false

(*
   Costly operation that translates a whole tree or subtree.

   The first pass translates it into a generic tree structure suitable
   to guess which node corresponds to each grammar rule.
   The second pass is a translation into a typed tree where each grammar
   node has its own type.

   This function is called:
   - once on the root of the program after removing extras
     (comments and other nodes that occur anywhere independently from
     the grammar);
   - once of each extra node, resulting in its own independent tree of type
     'extra'.
*)
let translate_tree src node trans_x =
  let matched_tree = Run.match_tree children_regexps src node in
  Option.map trans_x matched_tree


let translate_extra src (node : Tree_sitter_output_t.node) : CST.extra option =
  match node.type_ with
  | "comment" ->
      (match translate_tree src node trans_comment with
      | None -> None
      | Some x -> Some (`Comment (Run.get_loc node, x)))
  | _ -> None

let translate_root src root_node =
  translate_tree src root_node trans_source_file

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let opt_program, extras =
     Run.translate
       ~extras
       ~translate_root:(translate_root src)
       ~translate_extra:(translate_extra src)
       orig_root_node
  in
  Parsing_result.create src opt_program extras errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

