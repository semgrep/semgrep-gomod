(* Generated by ocaml-tree-sitter. *)
(*
   gomod grammar

   entrypoint: source_file
*)

open! Sexplib.Conv
open Tree_sitter_run

type raw_string_literal = Token.t

type identifier = Token.t

type imm_tok_prec_p1_pat_101b4f2 = Token.t (* pattern "[^\"\\n\\\\]+" *)

type pat_4fd4a56 = Token.t (* pattern .* *)

type escape_sequence = Token.t

type string_literal = [
    `Raw_str_lit of raw_string_literal (*tok*)
  | `Inte_str_lit of (
        Token.t (* "\"" *)
      * [
            `Imm_tok_prec_p1_pat_101b4f2 of imm_tok_prec_p1_pat_101b4f2
          | `Esc_seq of escape_sequence (*tok*)
        ]
          list (* zero or more *)
      * Token.t (* "\"" *)
    )
]

type string_or_ident = [
    `Str_lit of string_literal
  | `Id of identifier (*tok*)
]

type module_path = string_or_ident

type tool = string_or_ident

type toolchain_name = string_or_ident

type version = string_or_ident

type go_version = string_or_ident

type require_spec = (module_path * version * Token.t (* "\n" *))

type exclude_spec = (module_path * version * Token.t (* "\n" *))

type replace_spec = [
    `Module_path_opt_vers_EQGT_file_path_LF of (
        module_path
      * version option
      * Token.t (* "=>" *)
      * identifier (*tok*)
      * Token.t (* "\n" *)
    )
  | `Module_path_opt_vers_EQGT_module_path_vers_LF of (
        module_path
      * version option
      * Token.t (* "=>" *)
      * module_path
      * version
      * Token.t (* "\n" *)
    )
]

type retract_spec = (
    [
        `LBRACK_vers_COMMA_vers_RBRACK of (
            Token.t (* "[" *) * version * Token.t (* "," *) * version
          * Token.t (* "]" *)
        )
      | `Vers of version
    ]
  * Token.t (* "\n" *)
)

type directive = [
    `Module_dire of (
        Token.t (* "module" *)
      * [
            `Module_path of module_path
          | `LPAR_LF_module_path_LF_RPAR of (
                Token.t (* "(" *) * Token.t (* "\n" *) * module_path
              * Token.t (* "\n" *) * Token.t (* ")" *)
            )
        ]
    )
  | `Go_dire of (Token.t (* "go" *) * go_version * Token.t (* "\n" *))
  | `Tool_dire_c03956b of (
        Token.t (* "tool" *)
      * [
            `Tool of tool
          | `LPAR_LF_rep_tool_RPAR_LF of (
                Token.t (* "(" *)
              * Token.t (* "\n" *)
              * tool list (* zero or more *)
              * Token.t (* ")" *)
              * Token.t (* "\n" *)
            )
        ]
    )
  | `Tool_dire_55e7f4a of (Token.t (* "toolchain" *) * toolchain_name)
  | `Requ_dire of (
        Token.t (* "require" *)
      * [
            `Requ_spec of require_spec
          | `LPAR_LF_rep_requ_spec_RPAR_LF of (
                Token.t (* "(" *)
              * Token.t (* "\n" *)
              * require_spec list (* zero or more *)
              * Token.t (* ")" *)
              * Token.t (* "\n" *)
            )
        ]
    )
  | `Excl_dire of (
        Token.t (* "exclude" *)
      * [
            `Excl_spec of exclude_spec
          | `LPAR_LF_rep_excl_spec_RPAR_LF of (
                Token.t (* "(" *)
              * Token.t (* "\n" *)
              * exclude_spec list (* zero or more *)
              * Token.t (* ")" *)
              * Token.t (* "\n" *)
            )
        ]
    )
  | `Repl_dire of (
        Token.t (* "replace" *)
      * [
            `Repl_spec of replace_spec
          | `LPAR_LF_rep_repl_spec_RPAR_LF of (
                Token.t (* "(" *)
              * Token.t (* "\n" *)
              * replace_spec list (* zero or more *)
              * Token.t (* ")" *)
              * Token.t (* "\n" *)
            )
        ]
    )
  | `Retr_dire of (
        Token.t (* "retract" *)
      * [
            `LPAR_LF_rep_retr_spec_RPAR_LF of (
                Token.t (* "(" *)
              * Token.t (* "\n" *)
              * retract_spec list (* zero or more *)
              * Token.t (* ")" *)
              * Token.t (* "\n" *)
            )
          | `Retr_spec of retract_spec
        ]
    )
]

type source_file = directive list (* zero or more *)

type file_path (* inlined *) = identifier (*tok*)

type comment (* inlined *) = (Token.t (* "//" *) * pat_4fd4a56)

type interpreted_string_literal (* inlined *) = (
    Token.t (* "\"" *)
  * [
        `Imm_tok_prec_p1_pat_101b4f2 of imm_tok_prec_p1_pat_101b4f2
      | `Esc_seq of escape_sequence (*tok*)
    ]
      list (* zero or more *)
  * Token.t (* "\"" *)
)

type module_directive (* inlined *) = (
    Token.t (* "module" *)
  * [
        `Module_path of module_path
      | `LPAR_LF_module_path_LF_RPAR of (
            Token.t (* "(" *) * Token.t (* "\n" *) * module_path
          * Token.t (* "\n" *) * Token.t (* ")" *)
        )
    ]
)

type tool_directive (* inlined *) = (
    Token.t (* "tool" *)
  * [
        `Tool of tool
      | `LPAR_LF_rep_tool_RPAR_LF of (
            Token.t (* "(" *)
          * Token.t (* "\n" *)
          * tool list (* zero or more *)
          * Token.t (* ")" *)
          * Token.t (* "\n" *)
        )
    ]
)

type toolchain_directive (* inlined *) = (
    Token.t (* "toolchain" *) * toolchain_name
)

type go_directive (* inlined *) = (
    Token.t (* "go" *) * go_version * Token.t (* "\n" *)
)

type require_directive (* inlined *) = (
    Token.t (* "require" *)
  * [
        `Requ_spec of require_spec
      | `LPAR_LF_rep_requ_spec_RPAR_LF of (
            Token.t (* "(" *)
          * Token.t (* "\n" *)
          * require_spec list (* zero or more *)
          * Token.t (* ")" *)
          * Token.t (* "\n" *)
        )
    ]
)

type exclude_directive (* inlined *) = (
    Token.t (* "exclude" *)
  * [
        `Excl_spec of exclude_spec
      | `LPAR_LF_rep_excl_spec_RPAR_LF of (
            Token.t (* "(" *)
          * Token.t (* "\n" *)
          * exclude_spec list (* zero or more *)
          * Token.t (* ")" *)
          * Token.t (* "\n" *)
        )
    ]
)

type replace_directive (* inlined *) = (
    Token.t (* "replace" *)
  * [
        `Repl_spec of replace_spec
      | `LPAR_LF_rep_repl_spec_RPAR_LF of (
            Token.t (* "(" *)
          * Token.t (* "\n" *)
          * replace_spec list (* zero or more *)
          * Token.t (* ")" *)
          * Token.t (* "\n" *)
        )
    ]
)

type retract_directive (* inlined *) = (
    Token.t (* "retract" *)
  * [
        `LPAR_LF_rep_retr_spec_RPAR_LF of (
            Token.t (* "(" *)
          * Token.t (* "\n" *)
          * retract_spec list (* zero or more *)
          * Token.t (* ")" *)
          * Token.t (* "\n" *)
        )
      | `Retr_spec of retract_spec
    ]
)

type extra = [ `Comment of Loc.t * comment ]

type extras = extra list
